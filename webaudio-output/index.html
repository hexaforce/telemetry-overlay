<!doctype html>
<html>

<head>
  <meta charset="utf-8" />
  <script type="module" type="text/javascript">
    'use strict'

    const OfferOptions = {
      offerToReceiveVideo: 1,
      offerToReceiveAudio: 1,
    }

    const Constraints = {
      video: { frameRate: { ideal: 30, max: 60 }, width: { ideal: 640 }, height: { ideal: 360 } },
      // video: { frameRate: { ideal: 30, max: 60 }, width: { ideal: 1280 }, height: { ideal: 720 } },
      // video: { frameRate: { ideal: 30, max: 60 }, width: { ideal: 1920 }, height: { ideal: 1080 } },
      audio: { echoCancellation: true, noiseSuppression: true, autoGainControl: true },
    }

    import { preferredVideoCodecs, setSenderPriority } from './Support.js'

    import { StreamVisualizer } from './StreamVisualizer.js'

    const startButton = document.getElementById('startButton')
    const callButton = document.getElementById('callButton')
    const hangupButton = document.getElementById('hangupButton')
    callButton.disabled = true
    hangupButton.disabled = true

    // startButton
    // ------------------------------------------------------
    startButton.onclick = async () => {
      startButton.disabled = true
      Constraints.video.deviceId = { ideal: document.querySelector('select#videoSource').value }
      Constraints.audio.deviceId = { ideal: document.querySelector('select#audioSource').value }
      localVideo.srcObject = window.stream = await navigator.mediaDevices.getUserMedia(Constraints)
      callButton.disabled = false
    }

    // callButton
    // ------------------------------------------------------
    callButton.onclick = async () => {
      callButton.disabled = true
      hangupButton.disabled = false

      pc1 = new RTCPeerConnection()
      pc1.onicecandidate = ({ candidate }) => pc2.addIceCandidate(candidate)
      pc2 = new RTCPeerConnection()
      pc2.onicecandidate = ({ candidate }) => pc1.addIceCandidate(candidate)

      pc2.ontrack = ({ receiver, streams, track }) => {
        if (track.kind === 'video') {
          const { readable, writable } = receiver.createEncodedStreams()
          let keyFrameAnalyzer = new TransformStream({ transform })
          readable.pipeThrough(keyFrameAnalyzer).pipeTo(writable)
        }
        if (remoteVideo.srcObject !== streams[0]) {
          remoteVideo.srcObject = streams[0]
          new StreamVisualizer(streams[0], canvas).start()
        }
      }

      window.stream.getTracks().forEach((track) => pc1.addTrack(track, window.stream))

      const offer = await pc1.createOffer(OfferOptions)
      // setSenderPriority(pc1)

      await pc1.setLocalDescription(offer)
      await pc2.setRemoteDescription(offer)

      // preferredVideoCodecs(pc2.getTransceivers())

      const answer = await pc2.createAnswer()
      await pc2.setLocalDescription(answer)
      await pc1.setRemoteDescription(answer)
      // setTimeout(async () => {
      //   const stats = await pc1.getStats()
      //   stats.forEach((stat) => {
      //     if (!(stat.type === 'outbound-rtp')) return
      //     const codec = stats.get(stat.codecId)

      //     if (stat.kind === 'video') {
      //       document.getElementById('actualCodec').innerText = 'Using ' + codec.mimeType + (codec.sdpFmtpLine ? ' ' + codec.sdpFmtpLine + ' ' : '') + ', payloadType=' + codec.payloadType + '.'
      //       if (stat.encoderImplementation) {
      //         document.getElementById('actualCodec').innerText += ' Encoder: "' + stat.encoderImplementation + '".'
      //       }
      //       if (stat.powerEfficientEncoder !== undefined) {
      //         document.getElementById('actualCodec').innerText += ' Power efficient: ' + stat.powerEfficientEncoder + '.'
      //       }
      //     }
      //   })
      // }, 1000)
    }

    // hangupButton
    // ------------------------------------------------------
    hangupButton.onclick = () => {
      console.log('Ending call')
      pc1.close()
      pc1 = null
      pc2.close()
      pc2 = null
      hangupButton.disabled = true
      callButton.disabled = false
    }

    function transform(encodedFrame, controller) {
      const { data, type, timestamp, synchronizationSource } = encodedFrame
      const view = new DataView(data)
      const { byteLength } = data
      const keyframeBit = view.getUint8(0) & 0x01
      // console.log(view.getUint8(0).toString(16));

      if (videoSizeDisplay.innerText === '') {
        const { width, height, mimeType, payloadType } = encodedFrame.getMetadata()
        videoSizeDisplay.innerText = `${width}x${height} payload:${payloadType} mime:${mimeType}`
      }

      let isKeyFrame = (view.getUint8(0) & 0x01) === 0

      if (isKeyFrame) {
        keyFrameCount++
        keyFrameLastSize = byteLength
      } else {
        interFrameCount++
        interFrameLastSize = byteLength
      }
      if (type === prevFrameType && timestamp === prevFrameTimestamp && synchronizationSource === prevFrameSynchronizationSource) {
        duplicateCount++
      }

      prevFrameType = type
      prevFrameTimestamp = timestamp
      prevFrameSynchronizationSource = synchronizationSource
      controller.enqueue(encodedFrame)
    }

    const keyFrameCountDisplay = document.querySelector('#keyframe-count')
    const keyFrameSizeDisplay = document.querySelector('#keyframe-size')
    const interFrameCountDisplay = document.querySelector('#interframe-count')
    const interFrameSizeDisplay = document.querySelector('#interframe-size')
    const videoSizeDisplay = document.querySelector('#video-size')
    const duplicateCountDisplay = document.querySelector('#duplicate-count')

    let keyFrameCount = 0
    let interFrameCount = 0
    let keyFrameLastSize = 0
    let interFrameLastSize = 0
    let duplicateCount = 0

    let prevFrameType
    let prevFrameTimestamp
    let prevFrameSynchronizationSource

    // // Update the display of the counters once a second.
    setInterval(() => {
      keyFrameCountDisplay.innerText = keyFrameCount
      keyFrameSizeDisplay.innerText = keyFrameLastSize
      interFrameCountDisplay.innerText = interFrameCount
      interFrameSizeDisplay.innerText = interFrameLastSize
      duplicateCountDisplay.innerText = duplicateCount
    }, 500)

    const canvas = document.querySelector('canvas')

    const localVideo = document.getElementById('localVideo')
    const remoteVideo = document.getElementById('remoteVideo')

    let pc1
    let pc2
  </script>
</head>

<body>
  <div class="select">
    <label for="videoSource">Video source: </label><select id="videoSource"></select>
    <label for="audioSource">Audio source: </label><select id="audioSource"></select>
  </div>
  <div id="actualCodec"></div>
  <p>localVideo</p>
  <video id="localVideo" playsinline autoplay muted></video>
  <p>remoteVideo</p>
  <video id="remoteVideo" playsinline autoplay muted></video>
  <canvas></canvas>
  <div>
    <button id="startButton">Start</button>
    <button id="callButton">Call</button>
    <button id="hangupButton">Hang Up</button>
  </div>
  <p>View the console to see logging.</p>
  <div class="analyzer">
    Video size: <span id="video-size"></span><br />
    Keyframe count: <span id="keyframe-count"></span><br />
    Interframe count: <span id="interframe-count"></span><br />
    Last keyframe size: <span id="keyframe-size"></span><br />
    Last interframe size: <span id="interframe-size"></span><br />
    Duplicate count: <span id="duplicate-count"></span><br />
  </div>
</body>

</html>