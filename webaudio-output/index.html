<!doctype html>
<html>

<head>
  <meta charset="utf-8" />
  <script type="module" type="text/javascript">
    'use strict'

    const params = new URLSearchParams(window.location.search)
    const protocol = params.get('protocol')

    import { getDevices, setSenderPriority, setupReceiverTransform, isIPv4, toICE, requestPermission } from './Support.js'
    import { StreamVisualizer } from './StreamVisualizer.js'
    import { reportAggregate } from './Report.js'
    import { fixH264Codecs, preferredCodecs } from './Codec.js'
    import { SupportedType, MultimediaRecorder } from './MultimediaRecorder.js'

    const recorder = new MultimediaRecorder()

    WebSocket.prototype.originalSend = WebSocket.prototype.send
    WebSocket.prototype.send = function (type, ws1Id, ws2Id, data) {
      this.originalSend(JSON.stringify({ type, ws1Id, ws2Id, ...data }))
    }

    RTCDataChannel.prototype.originalSend = RTCDataChannel.prototype.send
    RTCDataChannel.prototype.send = function (type, data) {
      this.originalSend(JSON.stringify({ type, ...data }))
    }

    if (!!!window.RTCRtpScriptTransform) {
      const stream = new ReadableStream()
      window.postMessage(stream, '*', [stream])
    }

    let startTime
    let ws1
    let pc1
    if (protocol === 'transceiver') {
      ws1 = new WebSocket('wss://SERVER_IP_ADDRESS/ws', protocol)
      pc1 = new RTCPeerConnection()
      document.querySelector('.receiver').style.display = 'none'
    }
    let ws2
    let pc2
    if (protocol === 'receiver') {
      ws2 = new WebSocket('wss://SERVER_IP_ADDRESS/ws', protocol)
      pc2 = new RTCPeerConnection()
      document.querySelector('.transceiver').style.display = 'none'
    }
    let dc1
    let dc2

    const localCandidateAddress = {}
    const remoteCandidateAddress = {}

    if (pc1) {
      pc1.oniceconnectionstatechange = (event) => {
        console.log('ICE State Changed:', pc1.iceConnectionState)
        if ('connected' === pc1.iceConnectionState) {
          startTime = window.performance.now()
        }
      }
      pc1.onicecandidate = ({ candidate }) => {
        if (candidate) {
          if (isIPv4(candidate.address)) {
            ws1.send('ice', ws1.id, ws1.pair, { candidate })
          }
        }
      }
      dc1 = pc1.createDataChannel('pc1')
      dc1.onopen = () => {
        console.log('DataChannel open pc1')
        dc1.onmessage = ({ data }) => {
          const message = JSON.parse(data)
          console.log('DataChannel1 message:', message)
          const { type } = message
          if (type === 'position') {
            //
            window.navigator.geolocation.getCurrentPosition(
              ({ coords, timestamp }) => dc1.send('position', { coords, timestamp }),
              (err) => console.error('Error:', err),
            )
            //
          }
        }
      }
    }

    if (pc2) {
      pc2.oniceconnectionstatechange = (event) => {
        console.log('ICE State Changed:', pc2.iceConnectionState)
        if ('connected' === pc2.iceConnectionState) {
          setInterval(() => {
            pc2.getStats(null).then((stats) => {
              let result = reportAggregate(stats, remoteCandidateAddress, localCandidateAddress)
              document.querySelector('.stats-box').innerHTML = JSON.stringify(result, null, 2)
            })
          }, 1000)
        }
      }
      pc2.onicecandidate = ({ candidate }) => {
        if (candidate) {
          if (isIPv4(candidate.address)) {
            const ice = toICE(candidate.candidate)
            if (ice) localCandidateAddress[ice[3]] = ice[2]
            ws2.send('ice', ws2.pair, ws2.id, { candidate })
          }
        }
      }
      pc2.ondatachannel = ({ channel }) => {
        console.log('DataChannel open pc2')
        dc2 = channel
        dc2.onmessage = ({ data }) => {
          const message = JSON.parse(data)
          console.log('DataChannel2 message:', message)
          const { type } = message
          if (type === 'position') {
            //
            console.log('position:', message.coords)
            //
          } else if (type === 'deviceorientation') {
            //
            console.log('deviceorientation:', message)
            //
          } else if (type === 'deviceorientationabsolute') {
            //
            console.log('deviceorientationabsolute:', message)
            //
          } else if (type === 'devicemotion') {
            //
            console.log('devicemotion:', message)
            //
          }
        }
      }
      pc2.ontrack = ({ receiver, streams, track }) => {
        if (track.kind === 'video') {
          setupReceiverTransform(receiver)
        }
        if (track.kind === 'audio') {
          new StreamVisualizer(streams[0], document.querySelector('canvas')).start()
        }
        const remoteVideo = document.getElementById('video#remote')
        if (remoteVideo.srcObject !== streams[0]) {
          remoteVideo.srcObject = streams[0]
        }
      }
    }

    if (ws1) {
      ws1.onopen = async () => {
        console.log('ws1 connected')
        ws1.onclose = () => console.log('ws1 closed')
        ws1.onmessage = async ({ data }) => {
          const message = JSON.parse(data)
          const { type, ws1Id, ws2Id } = message
          if (type === 'session') {
            //
            ws1.id = message.sessionId
            //
          } else if (type === 'init') {
            //
            let devices = await getDevices()
            ws1.send('info', ws1Id, ws2Id, { devices })
            //
          } else if (type === 'start') {
            //
            window.stream = await navigator.mediaDevices.getUserMedia(message.constraints)
            document.getElementById('video#local').srcObject = window.stream
            window.stream.getTracks().forEach((track) => pc1.addTrack(track, window.stream))
            setSenderPriority(pc1)
            const offer = await pc1.createOffer()
            await pc1.setLocalDescription(offer)
            ws1.pair = ws2Id
            ws1.send('offer', ws1Id, ws2Id, { offer })
            //
          } else if (type === 'answer') {
            //
            await pc1.setRemoteDescription(new RTCSessionDescription(message.answer))
            //
          } else if (type === 'ice') {
            //
            await pc1.addIceCandidate(message.candidate)
            //
          }
        }
      }
    }

    if (ws2) {
      ws2.onopen = () => {
        console.log('ws2 connected')
        ws2.onclose = () => console.log('ws2 closed')
        ws2.onmessage = async ({ data }) => {
          const message = JSON.parse(data)
          const { type, ws1Id, ws2Id } = message
          if (type === 'session') {
            //
            ws2.id = message.sessionId
            message.transceivers.forEach((value) => {
              const option = document.createElement('option')
              option.value = value
              option.innerText = value
              transceivers.appendChild(option)
            })
            //
          } else if (type === 'info') {
            //
            const videoSelect = document.querySelector('select#videoSource')
            const audioSelect = document.querySelector('select#audioSource')
            while (videoSelect.firstChild) videoSelect.removeChild(videoSelect.firstChild)
            while (audioSelect.firstChild) audioSelect.removeChild(audioSelect.firstChild)
            message.devices.forEach(({ deviceId, kind, label }) => {
              const option = document.createElement('option')
              option.value = deviceId
              if (kind === 'videoinput') {
                option.text = label || `Camera ${videoSelect.length + 1}`
                videoSelect.appendChild(option)
              } else if (kind === 'audioinput') {
                option.text = label || `Microphone ${audioSelect.length + 1}`
                audioSelect.appendChild(option)
              }
            })
            //
          } else if (type === 'offer') {
            //
            await pc2.setRemoteDescription(new RTCSessionDescription(message.offer))
            fixH264Codecs(pc2.getTransceivers())
            preferredCodecs(pc2.getTransceivers())
            const answer = await pc2.createAnswer()
            await pc2.setLocalDescription(answer)
            ws2.send('answer', ws1Id, ws2Id, { answer })
            ws2.pair = ws1Id
            //
          } else if (type === 'ice') {
            //
            const ice = toICE(message.candidate.candidate)
            if (ice) remoteCandidateAddress[ice[3]] = ice[2]
            await pc2.addIceCandidate(message.candidate)
            //
          }
        }
      }
    }

    // init
    // ------------------------------------------------------
    async function init() {
      const ws1Id = transceivers.options[transceivers.selectedIndex].value
      ws2.send('init', ws1Id, ws2.id)
    }

    // start
    // ------------------------------------------------------
    async function start() {
      const constraints = {
        video: {
          frameRate: { ideal: 30, max: 60 },
          width: { ideal: 1920 },
          height: { ideal: 1080 },
          deviceId: {
            ideal: document.querySelector('select#videoSource').value,
          },
        },
        audio: {
          echoCancellation: true,
          noiseSuppression: true,
          autoGainControl: true,
          deviceId: { ideal: document.querySelector('select#audioSource').value },
        },
      }
      const ws1Id = transceivers.options[transceivers.selectedIndex].value
      ws2.send('start', ws1Id, ws2.id, { constraints })

      SupportedType.forEach((mimeType) => {
        const option = document.createElement('option')
        option.value = mimeType.value
        option.innerText = mimeType.label
        codecPreferences.appendChild(option)
      })
    }

    // hangup
    // ------------------------------------------------------
    async function hangup() {
      // localVideo.srcObject.getTracks().forEach((track) => track.stop())
      window.stream.getTracks().forEach((track) => track.stop())
    }

    // recordStart
    // ------------------------------------------------------
    async function recordStart() {
      const mimeType = codecPreferences.options[codecPreferences.selectedIndex].value
      if (mimeType.split(';', 1)[0] === 'video/mp4') {
        // Adjust sampling rate to 48khz.
        const track = window.stream.getAudioTracks()[0]
        if (track) {
          const { sampleRate } = track.getSettings()
          if (sampleRate != 48000) {
            track.stop()
            window.stream.removeTrack(track)
            const newStream = await navigator.mediaDevices.getUserMedia({ audio: { sampleRate: 48000 } })
            window.stream.addTrack(newStream.getTracks()[0])
          }
        }
      }
      recorder.start(window.stream, mimeType)
    }

    // recordStop
    // ------------------------------------------------------
    async function recordStop() {
      recorder.stop()
    }

    // recordDownload
    // ------------------------------------------------------
    async function recordDownload() {
      recorder.download('test')
    }

    // recordPlay
    // ------------------------------------------------------
    async function recordPlay() {
      recorder.play()
    }

    const initButton = document.getElementById('initButton')
    initButton.onclick = init

    const startButton = document.getElementById('startButton')
    startButton.onclick = start
    // startButton.onclick = async () => {
    //   startButton.disabled = true
    //   hangupButton.disabled = false
    //   codecPreferences.disabled = false
    //   recordButton.disabled = false
    // }

    const hangupButton = document.getElementById('hangupButton')
    hangupButton.disabled = true
    hangupButton.onclick = hangup
    // hangupButton.onclick = () => {
    //   pc1.close()
    //   pc2.close()
    //   pc1 = null
    //   pc2 = null

    //   localVideo.srcObject.getTracks().forEach((track) => track.stop())
    //   window.stream.getTracks().forEach((track) => track.stop())

    //   hangupButton.disabled = true

    //   codecPreferences.disabled = true
    //   recordButton.disabled = true

    //   startButton.disabled = false
    // }



    const codecPreferences = document.querySelector('#codecPreferences')

    const recordButton = document.querySelector('button#record')
    recordButton.onclick = async () => {
      if (recordButton.textContent === 'Start Recording') {
        recordStart()

        recordButton.textContent = 'Stop Recording'
        playButton.disabled = true
        downloadButton.disabled = true
        codecPreferences.disabled = true
      } else {
        recordStop()

        recordButton.textContent = 'Start Recording'
        playButton.disabled = false
        downloadButton.disabled = false
        codecPreferences.disabled = false
      }
    }

    const transceivers = document.querySelector('#transceivers')

    const playButton = document.querySelector('button#play')
    playButton.onclick = recordPlay

    const downloadButton = document.querySelector('button#download')
    downloadButton.onclick = recordDownload

    document.getElementById('positionButton').onclick = async () => dc2.send(JSON.stringify({ type: 'position' }))

    const testButton = document.getElementById('testButton')
    testButton.onclick = async () => {
      requestPermission(dc1)
    }
  </script>
  <style>
    .receiver {
      display: flex;
      flex-direction: column;
      gap: 10px;
      max-width: 300px;
    }
  </style>
</head>

<body>
  <div class="container">
    <div class="transceiver">
      <p>LocalVideo</p>
      <video id="local" playsinline autoplay muted></video>
    </div>

    <div class="receiver">
      <p>RemoteVideo</p>
      <video id="remote" playsinline autoplay muted></video>
      <script>

      </script>
      <canvas></canvas>
      <pre class="stats-box"></pre>

      <div class="select">
        Transceiver:
        <select id="transceivers"></select>
        <button id="initButton">Init</button>
        <label for="videoSource">Video source: </label><select id="videoSource"></select>
        <label for="audioSource">Audio source: </label><select id="audioSource"></select>
        <button id="startButton">Start</button>
        <button id="hangupButton">Hang Up</button>
      </div>
      <div>
        <button id="positionButton">position</button>
        <button id="testButton">test</button>
      </div>
      <div class="select">
        Recording format:
        <select id="codecPreferences" disabled></select>
        <button id="record" disabled>Start Recording</button>
        <button id="play" disabled>Play</button>
        <button id="download" disabled>Download</button>
        <video id="recordedPlay" playsinline loop></video>
      </div>
    </div>
  </div>
</body>

</html>