<!doctype html>
<html>

<head>
  <meta charset="utf-8" />
  <script type="module" type="text/javascript">

    'use strict'

    const startButton = document.getElementById('startButton')
    const callButton = document.getElementById('callButton')
    const hangupButton = document.getElementById('hangupButton')
    callButton.disabled = true
    hangupButton.disabled = true

    // startButton
    // ------------------------------------------------------
    startButton.onclick = async () => {
      startButton.disabled = true
      try {
        const stream = await navigator.mediaDevices.getUserMedia({
          // video: { frameRate: { ideal: 30, max: 60 }, width: { ideal: 1280 }, height: { ideal: 720 } },
          video: { frameRate: { ideal: 30, max: 60 }, width: { ideal: 1920 }, height: { ideal: 1080 } },
          // audio: { echoCancellation: true, noiseSuppression: true }
          audio: false
        })
        localVideo.srcObject = stream
        localStream = stream
        callButton.disabled = false
        smallButton.disabled = false
        vgaButton.disabled = false
        hdButton.disabled = false
      } catch (e) {
        alert(`getUserMedia() error: ${e.name}`)
      }
    }

    // callButton
    // ------------------------------------------------------
    callButton.onclick = async () => {
      callButton.disabled = true
      hangupButton.disabled = false

      startTime = window.performance.now()

      pc1 = new RTCPeerConnection()
      pc1.onicecandidate = ({ candidate }) => pc2.addIceCandidate(candidate)
      pc2 = new RTCPeerConnection({ encodedInsertableStreams: true })
      pc2.onicecandidate = ({ candidate }) => pc1.addIceCandidate(candidate)

      pc2.ontrack = (e) => {
        const frameStreams = e.receiver.createEncodedStreams()
        frameStreams.readable
          .pipeThrough(
            new TransformStream({
              transform: (encodedFrame, controller) => {
                const view = new DataView(encodedFrame.data)
                // We assume that the video is VP8.
                // TODO: Check the codec to see that it is.
                // The lowest value bit in the first byte is the keyframe indicator.
                // https://tools.ietf.org/html/rfc6386#section-9.1
                const keyframeBit = view.getUint8(0) & 0x01
                // console.log(view.getUint8(0).toString(16));
                if (keyframeBit === 0) {
                  keyFrameCount++
                  keyFrameLastSize = encodedFrame.data.byteLength
                } else {
                  interFrameCount++
                  interFrameLastSize = encodedFrame.data.byteLength
                }
                if (encodedFrame.type === prevFrameType && encodedFrame.timestamp === prevFrameTimestamp && encodedFrame.synchronizationSource === prevFrameSynchronizationSource) {
                  duplicateCount++
                }
                prevFrameType = encodedFrame.type
                prevFrameTimestamp = encodedFrame.timestamp
                prevFrameSynchronizationSource = encodedFrame.synchronizationSource
                controller.enqueue(encodedFrame)
              },
            }),
          )
          .pipeTo(frameStreams.writable)
        remoteVideo.srcObject = e.streams[0]
      }

      localStream.getTracks().forEach((track) => pc1.addTrack(track, localStream))

      try {
        const offer = await pc1.createOffer({
          offerToReceiveAudio: 0,
          offerToReceiveVideo: 1,
        })
        await onCreateOfferSuccess(offer)
      } catch (e) {
        onCreateSessionDescriptionError(e)
      }
    }

    // hangupButton
    // ------------------------------------------------------
    hangupButton.onclick = () => {
      pc1.close()
      pc2.close()
      pc1 = null
      pc2 = null
      hangupButton.disabled = true
      callButton.disabled = false
    }

    const smallButton = document.getElementById('size-small')
    smallButton.addEventListener('click', () => {
      localStream.getVideoTracks()[0].applyConstraints({ width: { exact: 180 } })
    })
    const vgaButton = document.getElementById('size-vga')
    vgaButton.addEventListener('click', () => {
      localStream.getVideoTracks()[0].applyConstraints({ width: { exact: 640 } })
    })
    const hdButton = document.getElementById('size-hd')
    hdButton.addEventListener('click', () => {
      localStream.getVideoTracks()[0].applyConstraints({ width: { exact: 1024 } })
    })

    const banner = document.querySelector('#banner')

    const supportsInsertableStreams = !!RTCRtpSender.prototype.createEncodedStreams

    if (!supportsInsertableStreams) {
      banner.innerText = 'Your browser does not support Insertable Streams. ' + 'This sample will not work.'
      startButton.disabled = true
    }

    let startTime
    const localVideo = document.getElementById('localVideo')
    const remoteVideo = document.getElementById('remoteVideo')

    localVideo.addEventListener('loadedmetadata', function () {
      console.log(`Local video videoWidth: ${this.videoWidth}px,  videoHeight: ${this.videoHeight}px`)
    })

    remoteVideo.addEventListener('loadedmetadata', function () {
      if (startTime) {
        const elapsedTime = window.performance.now() - startTime
        console.log('Setup time: ' + elapsedTime.toFixed(3) + 'ms')
        startTime = null
      }
    })

    let localStream
    let pc1
    let pc2

    function getName(pc) {
      return pc === pc1 ? 'pc1' : 'pc2'
    }

    function getOtherPc(pc) {
      return pc === pc1 ? pc2 : pc1
    }

    function onCreateSessionDescriptionError(error) {
      console.log(`Failed to create session description: ${error.toString()}`)
    }

    async function onCreateOfferSuccess(desc) {
      console.log(`Offer from pc1\n${desc.sdp}`)
      console.log('pc1 setLocalDescription start')
      try {
        await pc1.setLocalDescription(desc)
        onSetLocalSuccess(pc1)
      } catch (e) {
        onSetSessionDescriptionError()
      }

      console.log('pc2 setRemoteDescription start')
      try {
        await pc2.setRemoteDescription({ type: 'offer', sdp: desc.sdp.replace('red/90000', 'green/90000') })
        onSetRemoteSuccess(pc2)
      } catch (e) {
        onSetSessionDescriptionError()
      }

      console.log('pc2 createAnswer start')
      try {
        const answer = await pc2.createAnswer()
        await onCreateAnswerSuccess(answer)
      } catch (e) {
        onCreateSessionDescriptionError(e)
      }
    }

    function onSetLocalSuccess(pc) {
      console.log(`${getName(pc)} setLocalDescription complete`)
    }

    function onSetRemoteSuccess(pc) {
      console.log(`${getName(pc)} setRemoteDescription complete`)
    }

    function onSetSessionDescriptionError(error) {
      console.log(`Failed to set session description: ${error.toString()}`)
    }

    async function onCreateAnswerSuccess(desc) {
      console.log(`Answer from pc2:\n${desc.sdp}`)
      console.log('pc2 setLocalDescription start')
      try {
        await pc2.setLocalDescription(desc)
        onSetLocalSuccess(pc2)
      } catch (e) {
        onSetSessionDescriptionError(e)
      }
      console.log('pc1 setRemoteDescription start')
      try {
        await pc1.setRemoteDescription(desc)
        onSetRemoteSuccess(pc1)
      } catch (e) {
        onSetSessionDescriptionError(e)
      }
    }


    const keyFrameCountDisplay = document.querySelector('#keyframe-count')
    const keyFrameSizeDisplay = document.querySelector('#keyframe-size')
    const interFrameCountDisplay = document.querySelector('#interframe-count')
    const interFrameSizeDisplay = document.querySelector('#interframe-size')
    const videoSizeDisplay = document.querySelector('#video-size')
    const duplicateCountDisplay = document.querySelector('#duplicate-count')
    let keyFrameCount = 0
    let interFrameCount = 0
    let keyFrameLastSize = 0
    let interFrameLastSize = 0
    let duplicateCount = 0
    let prevFrameType
    let prevFrameTimestamp
    let prevFrameSynchronizationSource

    // Update the display of the counters once a second.
    setInterval(() => {
      keyFrameCountDisplay.innerText = keyFrameCount
      keyFrameSizeDisplay.innerText = keyFrameLastSize
      interFrameCountDisplay.innerText = interFrameCount
      interFrameSizeDisplay.innerText = interFrameLastSize
      duplicateCountDisplay.innerText = duplicateCount
    }, 500)

    remoteVideo.addEventListener('resize', () => {
      console.log(`Remote video size changed to ${remoteVideo.videoWidth}x${remoteVideo.videoHeight}`)
      // We'll use the first onsize callback as an indication that video has started
      // playing out.
      videoSizeDisplay.innerText = `${remoteVideo.videoWidth}x${remoteVideo.videoHeight}`
    })

  </script>
</head>

<body>
  <div id="container">
    <h3><span id="banner"></span></h3>
    <video id="localVideo" playsinline autoplay muted></video>
    <video id="remoteVideo" playsinline autoplay></video>
    <div class="box">
      <button id="startButton">Start</button>
      <button id="callButton">Call</button>
      <button id="hangupButton">Hang Up</button>
      <br /><br />
      <button id="size-small" disabled>Small</button>
      <button id="size-vga" disabled>VGA</button>
      <button id="size-hd" disabled>HD</button>
    </div>
    <p>View the console to see logging.</p>
    <div class="analyzer">
      Video size: <span id="video-size"></span><br />
      Keyframe count: <span id="keyframe-count"></span><br />
      Interframe count: <span id="interframe-count"></span><br />
      Last keyframe size: <span id="keyframe-size"></span><br />
      Last interframe size: <span id="interframe-size"></span><br />
      Duplicate count: <span id="duplicate-count"></span><br />
    </div>
  </div>
</body>

</html>